<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<style>
		body {
			user-select: none;
			-moz-user-select: none;
		}
		.zoomables {
			border: 1px solid black;
			width: 200px;
			height: 200px;
		}
		#zoomMe {
			position: absolute;
			top: 0px;
			left: 0px;

		}
	</style>

</head>
<body>
<img id="zoomMe" class="zoomables" style="transform: matrix(1,0,0,1, 150, 150);" src="https://bradylab.ucsd.edu/turk/experiments/Isabella/interferenceWM/Masking/color/interferenceWMMasking_V4/cross.png">

<script>


	/**
	 * 'Resize and move image' (output) on screen based on 'mouse action' (input)
	 * @param {HTMLElement} el
	 * @param {Event} e
	 */
	function transformByMouseEvent(el, e) {

		el.oldMouseX = el.newMouseX || 0;
		el.oldMouseY = el.newMouseY || 0;
		el.newMouseX = e.x;
		el.newMouseY = e.y;

		var moveXBy = 0;
		var moveYBy = 0;

		el.isDragging = false;
		if (e.type === 'mousedown') {
			el.mouseIsDown = true;
		}
		if (e.type === 'mouseup') {
			el.mouseIsDown = false;
		}
		if (el.mouseIsDown && e.type === 'mousemove') {
			el.isDragging = true;
			el.lastMousePos = true;
		}
		if(el.isDragging && el.lastMousePos){
			moveXBy += el.newMouseX - el.oldMouseX;
			moveYBy += el.newMouseY - el.oldMouseY;
		}


		var r = el.getBoundingClientRect();
		var enlargeOrShrinkBy = 0;
		var zoomFactor = .1;

		if (e.deltaY) {
			enlargeOrShrinkBy = e.deltaY > 0 ? -zoomFactor : zoomFactor;
			var mouseX = e.x,
					mouseY = e.y,
					centerX = r.left + r.width / 2,
					centerY = r.top + r.height / 2,
					newCenterXDiff = mouseX - centerX,
					newCenterYDiff = mouseY - centerY,
					currentScaleX = r.width / el.width,
					currentScaleY = r.height / el.height;
			moveXBy = -(newCenterXDiff / currentScaleX * enlargeOrShrinkBy);
			moveYBy = -(newCenterYDiff / currentScaleY * enlargeOrShrinkBy);
			//Adding constraints
			if(currentScaleX+enlargeOrShrinkBy >= 4 || currentScaleX+enlargeOrShrinkBy <= 0.5){
				moveXBy = 0;
				moveYBy = 0;
				enlargeOrShrinkBy = 0;
			}
		}
		transform(el, moveXBy, moveYBy, enlargeOrShrinkBy);
		e.preventDefault();
	}

	/**
	 * This gets the transformation matrix data in real time
	 * @param {HTMLElement} el
	 * @return {{scaleX: number, scaleY: number, translateY: number, translateX: number, skewX: number, skewY: number}}
	 */
	function getMatrix(el) {
		var matrix = el.style.transform.substring(7);
		matrix = matrix.slice(0, matrix.length-1).split(',').map(el=>el = parseFloat(el.trim()));
		return {
			scaleX: matrix[0],
			skewY: matrix[1],
			skewX: matrix[2],
			scaleY: matrix[3],
			translateX: matrix[4],
			translateY: matrix[5]
		};
	}

	/**
	 * Side effect: transform an element's geometrical visual appearance
	 * @param {HTMLElement} el
	 * @param {int} moveXBy How much to move left-right, from where it already is. 0 leaves it as it is.
	 * @param {int} moveYBy How much to move up-down, from where it already is. 0 leaves it as it is.
	 * @param {number} enlargeOrShrinkBy How big-small it should get, compared to however it already is. In percentage compared to baseline. 1 being 100%. 0 leaves it as it is.
	 * @return void
	 */
	function transform(el, moveXBy = 0, moveYBy = 0, enlargeOrShrinkBy = 0) {
		var m = getMatrix(el);
		m.translateX += moveXBy;
		m.translateY += moveYBy;
		m.scaleX += enlargeOrShrinkBy;
		m.scaleY += enlargeOrShrinkBy;
		el.style.transform = 'matrix('+Object.values(m).join(', ')+')';
	}

	/**
	 * Handles all mouse events
	 * @param {MouseEvent} e
	 * @return {boolean}
	 */
	function handleMouseEvents(e) {
		transformByMouseEvent(el, e);
	}

	var el = document.getElementById('zoomMe');
	el.mouseIsDown = false;
	el.lastMousePos = false;


	document.addEventListener("wheel", handleMouseEvents, {passive: false});
	document.addEventListener("mousemove", handleMouseEvents, {passive: false});
	el.addEventListener("mousedown", handleMouseEvents);
	document.addEventListener("mouseup", handleMouseEvents);
	document.addEventListener("mouseout", handleMouseEvents, {passive: false});

</script>
</body>
</html>
